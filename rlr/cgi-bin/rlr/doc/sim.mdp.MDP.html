<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Tue Jul 29 22:00:59 GMT+01:00 1997 -->
<title>
  Class sim.mdp.MDP
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-sim.mdp.html">This Package</a>  <a href="sim.mdp.LQR.html#_top_">Previous</a>  <a href="sim.mdp.XORmdp.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class sim.mdp.MDP
</h1>
<pre>
java.lang.Object
   |
   +----sim.mdp.MDP
</pre>
<hr>
<dl>
  <dt> public abstract class <b>MDP</b>
  <dt> extends Object
  <dt> implements <a href="watch.Watchable.html#_top_">Watchable</a>, <a href="parse.Parsable.html#_top_">Parsable</a>
</dl>
a Markov Decision Process or Markov Game that takes a state and action
 and returns a new state and a reinforcement.  It can be either
 deterministic or nondeterministic.  If the next state is
 fed back in as the state, it can run a simulation.  If the
 state is repeatedly randomized, it can be used for learning
 with random transitions.  If an MDP class is written for which
 an optimal policy and value function are known, then
 findAction() and findValue() will return them, otherwise
 they just return null and zero respectively.
 Revision 1.01 added the state parameter to the findValAct method
    <p>This code is (c) 1996 Leemon Baird and Mance Harmon
    <<a href=mailto:leemon@cs.cmu.edu>leemon@cs.cmu.edu</a>>,
    <a href=http://www.cs.cmu.edu/~baird>http://www.cs.cmu.edu/~baird</a><br>
    The source and object code may be redistributed freely.
    If the code is modified, please state so in the comments.
<p>
<dl>
  <dt> <b>Version:</b>
  <dd> 1.11, 22 July 97
  <dt> <b>Author:</b>
  <dd> Leemon Baird, Mance Harmon
</dl>
<hr>
<a name="index"></a>
<h2>
  <img src="images/variable-index.gif" width=207 height=38 alt="Variable Index">
</h2>
<dl>
  <dt> <img src="images/magenta-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#action"><b>action</b></a>
  <dd> an action vector (created in parse())
  <dt> <img src="images/magenta-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#nextState"><b>nextState</b></a>
  <dd> the state vector resulting from doing action in state (created in parse())
  <dt> <img src="images/magenta-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#state"><b>state</b></a>
  <dd> a state vector (created in parse())
  <dt> <img src="images/magenta-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#watchManager"><b>watchManager</b></a>
  <dd> the WatchManager that variables here may be registered with
  <dt> <img src="images/magenta-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#wmName"><b>wmName</b></a>
  <dd> the prefix string for the name of every watched variable (passed in to setWatchManager)
</dl>
<h2>
  <img src="images/constructor-index.gif" width=275 height=38 alt="Constructor Index">
</h2>
<dl>
  <dt> <img src="images/yellow-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#MDP()"><b>MDP</b></a>()
  <dd> 
</dl>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#actionSize()"><b>actionSize</b></a>()
  <dd> Return the number of elements in the action vector.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#BNF(int)"><b>BNF</b></a>(int)
  <dd> 
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#findValAct(matrix.MatrixD, matrix.MatrixD, sim.funApp.FunApp, matrix.MatrixD, pointer.PBoolean)"><b>findValAct</b></a>(MatrixD, MatrixD, FunApp, MatrixD, PBoolean)
  <dd> Find the value and best action of this state.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#findValue(matrix.MatrixD, matrix.MatrixD, pointer.PDouble, sim.funApp.FunApp, pointer.PDouble, matrix.MatrixD, pointer.PDouble, pointer.PBoolean, expression.NumExp, Random)"><b>findValue</b></a>(MatrixD, MatrixD, PDouble, FunApp, PDouble, MatrixD, PDouble, PBoolean, NumExp, Random)
  <dd> Find the max over action for <R+gammaV(x')> where V(x') is the value of the successor state
 given state x, R is the reinforcement, gamma is the discount factor.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getAction(matrix.MatrixD, matrix.MatrixD, Random)"><b>getAction</b></a>(MatrixD, MatrixD, Random)
  <dd> Return the next action possible in a state given the last action performed.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getName()"><b>getName</b></a>()
  <dd> Return the variable "name" that was passed into setWatchManager
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getParameters(int)"><b>getParameters</b></a>(int)
  <dd> Return a parameter array if BNF(), parse(), and unparse() are to be automated, null otherwise.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getState(matrix.MatrixD, pointer.PDouble, Random)"><b>getState</b></a>(MatrixD, PDouble, Random)
  <dd> Return the next state to be used for training in an epoch-wise system.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getWatchManager()"><b>getWatchManager</b></a>()
  <dd> Return the WatchManager set by setWatchManager().
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#initialAction(matrix.MatrixD, matrix.MatrixD, Random)"><b>initialAction</b></a>(MatrixD, MatrixD, Random)
  <dd> Return the initial action possible in a state.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#initialize(int)"><b>initialize</b></a>(int)
  <dd> Initialize, either partially or completely.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#initialState(matrix.MatrixD, Random)"><b>initialState</b></a>(MatrixD, Random)
  <dd> Return an initial state used for the start of epoch-wise training or for
 training on trajectories.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#nextState(matrix.MatrixD, matrix.MatrixD, matrix.MatrixD, pointer.PDouble, pointer.PBoolean, Random)"><b>nextState</b></a>(MatrixD, MatrixD, MatrixD, PDouble, PBoolean, Random)
  <dd> Find a (possibly stochastic) next state given a state and action,
 and return the (possibly stochastic) reinforcement received.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#numActions(matrix.MatrixD)"><b>numActions</b></a>(MatrixD)
  <dd> Return the number of actions in a given state.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#numPairs(pointer.PDouble)"><b>numPairs</b></a>(PDouble)
  <dd> Return the number of state/action pairs in the MDP for a given dt.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#numStates(pointer.PDouble)"><b>numStates</b></a>(PDouble)
  <dd> Return the number of states in the given MDP.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#parse(parse.Parser, int)"><b>parse</b></a>(Parser, int)
  <dd> Parse the input file to get the parameters for this object.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#randomAction(matrix.MatrixD, matrix.MatrixD, Random)"><b>randomAction</b></a>(MatrixD, MatrixD, Random)
  <dd> Generates a random action from those possible.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#randomState(matrix.MatrixD, Random)"><b>randomState</b></a>(MatrixD, Random)
  <dd> Generates a random state from those possible and returns it in the vector passed in.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#setWatchManager(watch.WatchManager, java.lang.String)"><b>setWatchManager</b></a>(WatchManager, String)
  <dd> Register all variables with this WatchManager.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#stateSize()"><b>stateSize</b></a>()
  <dd> Return the number of elements in the state vector.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#unparse(parse.Unparser, int)"><b>unparse</b></a>(Unparser, int)
  <dd> Output a description of this object that can be parsed with parse().
</dl>
<a name="variables"></a>
<h2>
  <img src="images/variables.gif" width=153 height=38 alt="Variables">
</h2>
<a name="watchManager"><img src="images/magenta-ball.gif" width=12 height=12 alt=" o "></a>
<b>watchManager</b>
<pre>
 protected <a href="watch.WatchManager.html#_top_">WatchManager</a> watchManager
</pre>
<dl>
  <dd> the WatchManager that variables here may be registered with<p>
</dl>
<a name="wmName"><img src="images/magenta-ball.gif" width=12 height=12 alt=" o "></a>
<b>wmName</b>
<pre>
 protected String wmName
</pre>
<dl>
  <dd> the prefix string for the name of every watched variable (passed in to setWatchManager)<p>
</dl>
<a name="state"><img src="images/magenta-ball.gif" width=12 height=12 alt=" o "></a>
<b>state</b>
<pre>
 protected <a href="matrix.MatrixD.html#_top_">MatrixD</a> state
</pre>
<dl>
  <dd> a state vector (created in parse())<p>
</dl>
<a name="action"><img src="images/magenta-ball.gif" width=12 height=12 alt=" o "></a>
<b>action</b>
<pre>
 protected <a href="matrix.MatrixD.html#_top_">MatrixD</a> action
</pre>
<dl>
  <dd> an action vector (created in parse())<p>
</dl>
<a name="nextState"><img src="images/magenta-ball.gif" width=12 height=12 alt=" o "></a>
<b>nextState</b>
<pre>
 protected <a href="matrix.MatrixD.html#_top_">MatrixD</a> nextState
</pre>
<dl>
  <dd> the state vector resulting from doing action in state (created in parse())<p>
</dl>
<a name="constructors"></a>
<h2>
  <img src="images/constructors.gif" width=231 height=38 alt="Constructors">
</h2>
<a name="MDP"></a>
<a name="MDP()"><img src="images/yellow-ball.gif" width=12 height=12 alt=" o "></a>
<b>MDP</b>
<pre>
 public MDP()
</pre>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="setWatchManager(watch.WatchManager, java.lang.String)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="setWatchManager"><b>setWatchManager</b></a>
<pre>
 public void setWatchManager(<a href="watch.WatchManager.html#_top_">WatchManager</a> wm,
                             String name)
</pre>
<dl>
  <dd> Register all variables with this WatchManager.
 Override this if there are internal variables that
 should be registered here.
<p>
</dl>
<a name="getName()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getName"><b>getName</b></a>
<pre>
 public String getName()
</pre>
<dl>
  <dd> Return the variable "name" that was passed into setWatchManager
<p>
</dl>
<a name="getWatchManager()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getWatchManager"><b>getWatchManager</b></a>
<pre>
 public <a href="watch.WatchManager.html#_top_">WatchManager</a> getWatchManager()
</pre>
<dl>
  <dd> Return the WatchManager set by setWatchManager().
<p>
</dl>
<a name="numStates(pointer.PDouble)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="numStates"><b>numStates</b></a>
<pre>
 public abstract int numStates(<a href="pointer.PDouble.html#_top_">PDouble</a> dt)
</pre>
<dl>
  <dd> Return the number of states in the given MDP. If the number of states is infinite, then
 a parameter to the MDP should be defined that is the sample size of a pseudo-epoch.  In
 other words, an artificial epoch size should be passed as a parameter to the MDP object
 that defines the length of an epoch.  If the number of states is finite, then the number
 of states is a function of the time step size dt.  For this reason a step size dt is passed
 into this object.
<p>
</dl>
<a name="stateSize()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="stateSize"><b>stateSize</b></a>
<pre>
 public abstract int stateSize()
</pre>
<dl>
  <dd> Return the number of elements in the state vector.
<p>
</dl>
<a name="initialState(matrix.MatrixD, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="initialState"><b>initialState</b></a>
<pre>
 public abstract void initialState(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                                   <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Return an initial state used for the start of epoch-wise training or for
 training on trajectories.
 This might not be a single state but could be a set of starting states.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> Vector passed in was wrong length.
  </dl></dd>
</dl>
<a name="getState(matrix.MatrixD, pointer.PDouble, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getState"><b>getState</b></a>
<pre>
 public abstract void getState(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                               <a href="pointer.PDouble.html#_top_">PDouble</a> dt,
                               <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Return the next state to be used for training in an epoch-wise system.
 This method is different than nextState() in that nextState() returns the state
 transitioned to as a function of the dynamics of the system.  This object simply
 returns another state to be trained upon when performing epoch-wise training.  This
 method should incrementally return unique states until all states in an epoch have
 been used for training.  For example: if state space consists of 20 unique states, then
 this method will return a unique state until all 20 states have been return.  The method
 would then start over in a new series of the same 20 states.  The parameters are the last
 state used and a time step size.  In short, this is an iterator over all states in state space.
 If state space is infinite this method should not be used and is not meaningful.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> Vector passed in was wrong length.
  </dl></dd>
</dl>
<a name="actionSize()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="actionSize"><b>actionSize</b></a>
<pre>
 public abstract int actionSize()
</pre>
<dl>
  <dd> Return the number of elements in the action vector.
<p>
</dl>
<a name="initialAction(matrix.MatrixD, matrix.MatrixD, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="initialAction"><b>initialAction</b></a>
<pre>
 public abstract void initialAction(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                                    <a href="matrix.MatrixD.html#_top_">MatrixD</a> action,
                                    <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Return the initial action possible in a state. This method is used when one has to iterate
 over all possible actions in a given state.  Given a state, this method should return the
 initial action possible in the given state.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> Vector passed in was wrong length.
  </dl></dd>
</dl>
<a name="getAction(matrix.MatrixD, matrix.MatrixD, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getAction"><b>getAction</b></a>
<pre>
 public abstract void getAction(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                                <a href="matrix.MatrixD.html#_top_">MatrixD</a> action,
                                <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Return the next action possible in a state given the last action performed.
 This performs the same function as that of getState() in the sense that this serves
 as an iterator over actions instead of states.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> Vector passed in was wrong length.
  </dl></dd>
</dl>
<a name="numActions(matrix.MatrixD)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="numActions"><b>numActions</b></a>
<pre>
 public abstract int numActions(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state)
</pre>
<dl>
  <dd> Return the number of actions in a given state. For simplicity this should be the same
 for all states.  However, the state is being passed in to this method so that future
 code can take advantage of this parameter if necessary.
<p>
</dl>
<a name="numPairs(pointer.PDouble)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="numPairs"><b>numPairs</b></a>
<pre>
 public abstract int numPairs(<a href="pointer.PDouble.html#_top_">PDouble</a> dt)
</pre>
<dl>
  <dd> Return the number of state/action pairs in the MDP for a given dt. This is used for epoch-wise
 training.  An epoch would  consist of all state/action pairs for a given MDP and is a function
 of the step size dt.
<p>
</dl>
<a name="randomAction(matrix.MatrixD, matrix.MatrixD, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="randomAction"><b>randomAction</b></a>
<pre>
 public abstract void randomAction(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                                   <a href="matrix.MatrixD.html#_top_">MatrixD</a> action,
                                   <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Generates a random action from those possible.  Accepts a state and passes back an action.
 Each action variable should be on a seperate row.  action should be a vector (single-column matrix): Nx1
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> Vector passed in was wrong length.
  </dl></dd>
</dl>
<a name="randomState(matrix.MatrixD, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="randomState"><b>randomState</b></a>
<pre>
 public abstract void randomState(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                                  <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Generates a random state from those possible and returns it in the vector passed in.
 This should NOT include terminal states where the value is known.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> Vector passed in was wrong length.
  </dl></dd>
</dl>
<a name="nextState(matrix.MatrixD, matrix.MatrixD, matrix.MatrixD, pointer.PDouble, pointer.PBoolean, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="nextState"><b>nextState</b></a>
<pre>
 public abstract double nextState(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                                  <a href="matrix.MatrixD.html#_top_">MatrixD</a> action,
                                  <a href="matrix.MatrixD.html#_top_">MatrixD</a> newState,
                                  <a href="pointer.PDouble.html#_top_">PDouble</a> dt,
                                  <a href="pointer.PBoolean.html#_top_">PBoolean</a> valueKnown,
                                  <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Find a (possibly stochastic) next state given a state and action,
 and return the (possibly stochastic) reinforcement received.
 All 3 should be vectors (single-column matrices).
 The duration of the time step, dt, is also returned.  Most MDPs
 will generally make this a constant, given in the parsed string.
 If the resulting states value is perfectly known then the flag valueKnown should be
 set to true.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> if sizes aren't right.
  </dl></dd>
</dl>
<a name="findValAct(matrix.MatrixD, matrix.MatrixD, sim.funApp.FunApp, matrix.MatrixD, pointer.PBoolean)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="findValAct"><b>findValAct</b></a>
<pre>
 public abstract double findValAct(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                                   <a href="matrix.MatrixD.html#_top_">MatrixD</a> action,
                                   <a href="sim.funApp.FunApp.html#_top_">FunApp</a> f,
                                   <a href="matrix.MatrixD.html#_top_">MatrixD</a> outputs,
                                   <a href="pointer.PBoolean.html#_top_">PBoolean</a> valueKnown) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Find the value and best action of this state.  This returns the value of a given state as a double.
 This also destroys the action that is passed in by replacing it with the best action.  This
 method always returns a value that is a function of state/action pairs.  The value associated with
 these state/action pairs might be Q-values or advantages, but it is not important to know which
 learning algorithm is being used.  This method should simply find the min or max value as a function
 of the state/action pairs in the given state.  For example, if Q-learning is the learning algorithm,
 then one would find the max Q-value for the given state and return that value.
 The action associated with that Q-value would be passed back.  The state/action pair with the
 max Q-value should be evaluated last so that findGradients() can be called from within
 the learning algorithm without having to call function.evaluate().
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> column vectors are wrong size or shape
  </dl></dd>
</dl>
<a name="findValue(matrix.MatrixD, matrix.MatrixD, pointer.PDouble, sim.funApp.FunApp, pointer.PDouble, matrix.MatrixD, pointer.PDouble, pointer.PBoolean, expression.NumExp, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="findValue"><b>findValue</b></a>
<pre>
 public abstract double findValue(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                                  <a href="matrix.MatrixD.html#_top_">MatrixD</a> action,
                                  <a href="pointer.PDouble.html#_top_">PDouble</a> gamma,
                                  <a href="sim.funApp.FunApp.html#_top_">FunApp</a> f,
                                  <a href="pointer.PDouble.html#_top_">PDouble</a> dt,
                                  <a href="matrix.MatrixD.html#_top_">MatrixD</a> outputs,
                                  <a href="pointer.PDouble.html#_top_">PDouble</a> reinforcement,
                                  <a href="pointer.PBoolean.html#_top_">PBoolean</a> valueKnown,
                                  NumExp explorationFactor,
                                  <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Find the max over action for <R+gammaV(x')> where V(x') is the value of the successor state
 given state x, R is the reinforcement, gamma is the discount factor.  This method is used in
 the object ValIteration (value iteration). The max value over actions (<R+gammaV(x')>) is returned.
 The state reached after performing the optimal action should be returned 'explorationFactor' percent of
 the time in the parameter 'state'.  The state resulting from a random action will be returned
 1-explorationFactor percent of the time.  The possibility of explorationFactor==null must be handled.
 The action parameter must be checked for a null value before implementing.  The learning
 object 'ValueIteration' passes in a null in the place 'action'.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> column vectors are wrong size or shape
  </dl></dd>
</dl>
<a name="getParameters(int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getParameters"><b>getParameters</b></a>
<pre>
 public Object[][] getParameters(int lang)
</pre>
<dl>
  <dd> Return a parameter array if BNF(), parse(), and unparse() are to be automated, null otherwise.
<p>
  <dd><dl>
    <dt> <b>See Also:</b>
    <dd> <a href="parse.Parsable.html#getParameters">getParameters</a>
  </dl></dd>
</dl>
<a name="BNF(int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="BNF"><b>BNF</b></a>
<pre>
 public abstract String BNF(int lang)
</pre>
<a name="unparse(parse.Unparser, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="unparse"><b>unparse</b></a>
<pre>
 public abstract void unparse(<a href="parse.Unparser.html#_top_">Unparser</a> u,
                              int lang)
</pre>
<dl>
  <dd> Output a description of this object that can be parsed with parse().
 Also creates the state/action/nextState vectors
<p>
  <dd><dl>
    <dt> <b>See Also:</b>
    <dd> <a href="parse.Parsable.html#_top_">Parsable</a>
  </dl></dd>
</dl>
<a name="parse(parse.Parser, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="parse"><b>parse</b></a>
<pre>
 public abstract Object parse(<a href="parse.Parser.html#_top_">Parser</a> p,
                              int lang) throws <a href="parse.ParserException.html#_top_">ParserException</a>
</pre>
<dl>
  <dd> Parse the input file to get the parameters for this object.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="parse.ParserException.html#_top_">ParserException</a>
    <dd> parser didn't find the required token
  </dl></dd>
</dl>
<a name="initialize(int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="initialize"><b>initialize</b></a>
<pre>
 public void initialize(int level)
</pre>
<dl>
  <dd> Initialize, either partially or completely.
<p>
  <dd><dl>
    <dt> <b>See Also:</b>
    <dd> <a href="parse.Parsable.html#initialize">initialize</a>
  </dl></dd>
</dl>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-sim.mdp.html">This Package</a>  <a href="sim.mdp.LQR.html#_top_">Previous</a>  <a href="sim.mdp.XORmdp.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
