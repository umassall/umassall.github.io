<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Tue Jul 29 22:00:59 GMT+01:00 1997 -->
<title>
  Class sim.mdp.GridWorld
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-sim.mdp.html">This Package</a>  <a href="Package-sim.mdp.html">Previous</a>  <a href="sim.mdp.HC.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class sim.mdp.GridWorld
</h1>
<pre>
java.lang.Object
   |
   +----<a href="sim.mdp.MDP.html#_top_">sim.mdp.MDP</a>
           |
           +----sim.mdp.GridWorld
</pre>
<hr>
<dl>
  <dt> public class <b>GridWorld</b>
  <dt> extends <a href="sim.mdp.MDP.html#_top_">MDP</a>
</dl>
A Markov Decision Process or Markov Game that takes a state and action
 and returns a new state and a reinforcement.  It can be either
 deterministic or nondeterministic.  If the next state is
 fed back in as the state, it can run a simulation.  If the
 state is repeatedly randomized, it can be used for learning
 with random transitions.
    <p>This code is (c) 1996 Leemon Baird and Mance Harmon
    <<a href=mailto:leemon@cs.cmu.edu>leemon@cs.cmu.edu</a>>,
    <a href=http://www.cs.cmu.edu/~baird>http://www.cs.cmu.edu/~baird</a><br>
    The source and object code may be redistributed freely.
    If the code is modified, please state so in the comments.
<p>
<dl>
  <dt> <b>Version:</b>
  <dd> 1.04, 25 June 97
  <dt> <b>Author:</b>
  <dd> Mance Harmon
</dl>
<hr>
<a name="index"></a>
<h2>
  <img src="images/variable-index.gif" width=207 height=38 alt="Variable Index">
</h2>
<dl>
  <dt> <img src="images/magenta-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#action"><b>action</b></a>
  <dd> an action vector (created in parse())
  <dt> <img src="images/magenta-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#count1"><b>count1</b></a>
  <dd> Counters used in epoch-wise training
  <dt> <img src="images/magenta-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#count2"><b>count2</b></a>
  <dd> 
  <dt> <img src="images/magenta-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#granFactor"><b>granFactor</b></a>
  <dd> The depth in both the x and y dimension of the gridworld.
  <dt> <img src="images/magenta-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#nextState"><b>nextState</b></a>
  <dd> the state vector resulting from doing action in state (created in parse())
  <dt> <img src="images/magenta-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#random"><b>random</b></a>
  <dd> The random number generator
  <dt> <img src="images/magenta-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#state"><b>state</b></a>
  <dd> a state vector (created in parse())
  <dt> <img src="images/magenta-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#watchManager"><b>watchManager</b></a>
  <dd> the WatchManager that variables here may be registered with
</dl>
<h2>
  <img src="images/constructor-index.gif" width=275 height=38 alt="Constructor Index">
</h2>
<dl>
  <dt> <img src="images/yellow-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#GridWorld()"><b>GridWorld</b></a>()
  <dd> 
</dl>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#actionSize()"><b>actionSize</b></a>()
  <dd> Return the number of elements in the action vector.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#BNF(int)"><b>BNF</b></a>(int)
  <dd> 
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#findValAct(matrix.MatrixD, matrix.MatrixD, sim.funApp.FunApp, matrix.MatrixD, pointer.PBoolean)"><b>findValAct</b></a>(MatrixD, MatrixD, FunApp, MatrixD, PBoolean)
  <dd> Find the value and best action of this state.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#findValue(matrix.MatrixD, matrix.MatrixD, pointer.PDouble, sim.funApp.FunApp, pointer.PDouble, matrix.MatrixD, pointer.PDouble, pointer.PBoolean, expression.NumExp, Random)"><b>findValue</b></a>(MatrixD, MatrixD, PDouble, FunApp, PDouble, MatrixD, PDouble, PBoolean, NumExp, Random)
  <dd> Find the max over action for <R+gammaV(x')> where V(x') is the value of the successor state
 given state x, R is the reinforcement, gamma is the discount factor.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getAction(matrix.MatrixD, matrix.MatrixD, Random)"><b>getAction</b></a>(MatrixD, MatrixD, Random)
  <dd> Return the next action possible in a state given the last action performed.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getState(matrix.MatrixD, pointer.PDouble, Random)"><b>getState</b></a>(MatrixD, PDouble, Random)
  <dd> Return the next state to be used for training in an epoch-wise system.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getWatchManager()"><b>getWatchManager</b></a>()
  <dd> Return the WatchManager set by setWatchManager().
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#initialAction(matrix.MatrixD, matrix.MatrixD, Random)"><b>initialAction</b></a>(MatrixD, MatrixD, Random)
  <dd> Return the initial action possible in a state.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#initialState(matrix.MatrixD, Random)"><b>initialState</b></a>(MatrixD, Random)
  <dd> Return an initial state used for the start of epoch-wise training or for
 training on trajectories.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#nextState(matrix.MatrixD, matrix.MatrixD, matrix.MatrixD, pointer.PDouble, pointer.PBoolean, Random)"><b>nextState</b></a>(MatrixD, MatrixD, MatrixD, PDouble, PBoolean, Random)
  <dd> Find a next state given a state and action, and return the reinforcement received.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#numActions(matrix.MatrixD)"><b>numActions</b></a>(MatrixD)
  <dd> Return the number of actions in a given state.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#numPairs(pointer.PDouble)"><b>numPairs</b></a>(PDouble)
  <dd> Return the number of state/action pairs in the MDP for a given dt.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#numStates(pointer.PDouble)"><b>numStates</b></a>(PDouble)
  <dd> The number of states for this MDP is determined by the granularity factor that is passed in as
 a  parameter.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#parse(parse.Parser, int)"><b>parse</b></a>(Parser, int)
  <dd> Parse the input file to get the parameters for this object.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#randomAction(matrix.MatrixD, matrix.MatrixD, Random)"><b>randomAction</b></a>(MatrixD, MatrixD, Random)
  <dd> Generates a random action from those possible.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#randomState(matrix.MatrixD, Random)"><b>randomState</b></a>(MatrixD, Random)
  <dd> Generates a random state from those possible and returns it in the vector passed in.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#setWatchManager(watch.WatchManager, java.lang.String)"><b>setWatchManager</b></a>(WatchManager, String)
  <dd> Register all variables with this WatchManager.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#stateSize()"><b>stateSize</b></a>()
  <dd> Return the number of elements in the state vector.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#unparse(parse.Unparser, int)"><b>unparse</b></a>(Unparser, int)
  <dd> Output a description of this object that can be parsed with parse().
</dl>
<a name="variables"></a>
<h2>
  <img src="images/variables.gif" width=153 height=38 alt="Variables">
</h2>
<a name="watchManager"><img src="images/magenta-ball.gif" width=12 height=12 alt=" o "></a>
<b>watchManager</b>
<pre>
 protected <a href="watch.WatchManager.html#_top_">WatchManager</a> watchManager
</pre>
<dl>
  <dd> the WatchManager that variables here may be registered with<p>
</dl>
<a name="state"><img src="images/magenta-ball.gif" width=12 height=12 alt=" o "></a>
<b>state</b>
<pre>
 protected <a href="matrix.MatrixD.html#_top_">MatrixD</a> state
</pre>
<dl>
  <dd> a state vector (created in parse())<p>
</dl>
<a name="action"><img src="images/magenta-ball.gif" width=12 height=12 alt=" o "></a>
<b>action</b>
<pre>
 protected <a href="matrix.MatrixD.html#_top_">MatrixD</a> action
</pre>
<dl>
  <dd> an action vector (created in parse())<p>
</dl>
<a name="nextState"><img src="images/magenta-ball.gif" width=12 height=12 alt=" o "></a>
<b>nextState</b>
<pre>
 protected <a href="matrix.MatrixD.html#_top_">MatrixD</a> nextState
</pre>
<dl>
  <dd> the state vector resulting from doing action in state (created in parse())<p>
</dl>
<a name="random"><img src="images/magenta-ball.gif" width=12 height=12 alt=" o "></a>
<b>random</b>
<pre>
 protected <a href="Random.html#_top_">Random</a> random
</pre>
<dl>
  <dd> The random number generator<p>
</dl>
<a name="granFactor"><img src="images/magenta-ball.gif" width=12 height=12 alt=" o "></a>
<b>granFactor</b>
<pre>
 protected IntExp granFactor
</pre>
<dl>
  <dd> The depth in both the x and y dimension of the gridworld.<p>
</dl>
<a name="count1"><img src="images/magenta-ball.gif" width=12 height=12 alt=" o "></a>
<b>count1</b>
<pre>
 protected int count1
</pre>
<dl>
  <dd> Counters used in epoch-wise training<p>
</dl>
<a name="count2"><img src="images/magenta-ball.gif" width=12 height=12 alt=" o "></a>
<b>count2</b>
<pre>
 protected int count2
</pre>
<a name="constructors"></a>
<h2>
  <img src="images/constructors.gif" width=231 height=38 alt="Constructors">
</h2>
<a name="GridWorld"></a>
<a name="GridWorld()"><img src="images/yellow-ball.gif" width=12 height=12 alt=" o "></a>
<b>GridWorld</b>
<pre>
 public GridWorld()
</pre>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="setWatchManager(watch.WatchManager, java.lang.String)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="setWatchManager"><b>setWatchManager</b></a>
<pre>
 public void setWatchManager(<a href="watch.WatchManager.html#_top_">WatchManager</a> wm,
                             String name)
</pre>
<dl>
  <dd> Register all variables with this WatchManager.
 Override this if there are internal variables that
 should be registered here.
<p>
  <dd><dl>
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#setWatchManager(watch.WatchManager, java.lang.String)">setWatchManager</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="getWatchManager()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getWatchManager"><b>getWatchManager</b></a>
<pre>
 public <a href="watch.WatchManager.html#_top_">WatchManager</a> getWatchManager()
</pre>
<dl>
  <dd> Return the WatchManager set by setWatchManager().
<p>
  <dd><dl>
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#getWatchManager()">getWatchManager</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="numStates(pointer.PDouble)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="numStates"><b>numStates</b></a>
<pre>
 public int numStates(<a href="pointer.PDouble.html#_top_">PDouble</a> dt)
</pre>
<dl>
  <dd> The number of states for this MDP is determined by the granularity factor that is passed in as
 a  parameter.  A granularity of 10 would produce a state space containing 121 states:
 sqr(granularity+1)
<p>
  <dd><dl>
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#numStates(pointer.PDouble)">numStates</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="stateSize()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="stateSize"><b>stateSize</b></a>
<pre>
 public int stateSize()
</pre>
<dl>
  <dd> Return the number of elements in the state vector. In this case the state is a point
 (x,y) in a 2D Euclidean space.
<p>
  <dd><dl>
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#stateSize()">stateSize</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="initialState(matrix.MatrixD, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="initialState"><b>initialState</b></a>
<pre>
 public void initialState(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                          <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Return an initial state used for the start of epoch-wise training or for
 training on trajectories. The start state for this MDP is the lower left
 corner of the 2D grid (0,0).
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> Vector passed in was wrong length.
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#initialState(matrix.MatrixD, Random)">initialState</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="getState(matrix.MatrixD, pointer.PDouble, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getState"><b>getState</b></a>
<pre>
 public void getState(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                      <a href="pointer.PDouble.html#_top_">PDouble</a> dt,
                      <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Return the next state to be used for training in an epoch-wise system.
 This method is different than nextState() in that nextState() returns the state
 transitioned to as a function of the dynamics of the system.  This object simply
 returns another state to be trained upon when performing epoch-wise training.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> Vector passed in was wrong length.
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#getState(matrix.MatrixD, pointer.PDouble, Random)">getState</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="actionSize()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="actionSize"><b>actionSize</b></a>
<pre>
 public int actionSize()
</pre>
<dl>
  <dd> Return the number of elements in the action vector. The action vector is of length 1 and
 has 4 possible values: 0 - East, 0.25 - North, 0.5 - West, 0.75 - South.
<p>
  <dd><dl>
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#actionSize()">actionSize</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="initialAction(matrix.MatrixD, matrix.MatrixD, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="initialAction"><b>initialAction</b></a>
<pre>
 public void initialAction(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                           <a href="matrix.MatrixD.html#_top_">MatrixD</a> action,
                           <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Return the initial action possible in a state. This method is used when one has to iterate
 over all possible actions in a given state.  Given a state, this method should return the
 initial action possible in the given state.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> Vector passed in was wrong length.
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#initialAction(matrix.MatrixD, matrix.MatrixD, Random)">initialAction</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="getAction(matrix.MatrixD, matrix.MatrixD, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getAction"><b>getAction</b></a>
<pre>
 public void getAction(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                       <a href="matrix.MatrixD.html#_top_">MatrixD</a> action,
                       <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Return the next action possible in a state given the last action performed.
 This performs the same function as that of getState() in the sense that this serves
 as an iterator over actions instead of states.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> Vector passed in was wrong length.
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#getAction(matrix.MatrixD, matrix.MatrixD, Random)">getAction</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="numActions(matrix.MatrixD)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="numActions"><b>numActions</b></a>
<pre>
 public int numActions(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state)
</pre>
<dl>
  <dd> Return the number of actions in a given state. For this MDP this number is constant for
 all states.  There are 4 actions possible in each state:
 0 - East, 0.25 - North, 0.5 - West, 0.75 - South.
<p>
  <dd><dl>
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#numActions(matrix.MatrixD)">numActions</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="numPairs(pointer.PDouble)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="numPairs"><b>numPairs</b></a>
<pre>
 public int numPairs(<a href="pointer.PDouble.html#_top_">PDouble</a> dt)
</pre>
<dl>
  <dd> Return the number of state/action pairs in the MDP for a given dt. This is used for epoch-wise
 training.  An epoch would consist of all state/action pairs for a given MDP and is a function
 of the step size dt. For this MDP we have a continuum of state/action pairs because we have
 a continuum of states.  The value returned from this method will be the pseudo-epoch size
 passed in to this MDP is the parameter called epochSize.
<p>
  <dd><dl>
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#numPairs(pointer.PDouble)">numPairs</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="randomAction(matrix.MatrixD, matrix.MatrixD, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="randomAction"><b>randomAction</b></a>
<pre>
 public void randomAction(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                          <a href="matrix.MatrixD.html#_top_">MatrixD</a> action,
                          <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Generates a random action from those possible.  Accepts a state and passes back an action.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> Vector passed in was wrong length.
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#randomAction(matrix.MatrixD, matrix.MatrixD, Random)">randomAction</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="randomState(matrix.MatrixD, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="randomState"><b>randomState</b></a>
<pre>
 public void randomState(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                         <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Generates a random state from those possible and returns it in the vector passed in.
 This returns a vector of length 2.  Each element is in the range [0,1].
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> Vector passed in was wrong length.
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#randomState(matrix.MatrixD, Random)">randomState</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="nextState(matrix.MatrixD, matrix.MatrixD, matrix.MatrixD, pointer.PDouble, pointer.PBoolean, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="nextState"><b>nextState</b></a>
<pre>
 public double nextState(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                         <a href="matrix.MatrixD.html#_top_">MatrixD</a> action,
                         <a href="matrix.MatrixD.html#_top_">MatrixD</a> newState,
                         <a href="pointer.PDouble.html#_top_">PDouble</a> dt,
                         <a href="pointer.PBoolean.html#_top_">PBoolean</a> valueKnown,
                         <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Find a next state given a state and action, and return the reinforcement received.
 All 3 should be vectors (single-column matrices).
 The duration of the time step, dt, is also returned.  Most MDPs
 will generally make this a constant, given in the parsed string.
 The goal state is the upper right corner of the grid world (x>1-dt, y>1-dt).
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> if sizes aren't right.
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#nextState(matrix.MatrixD, matrix.MatrixD, matrix.MatrixD, pointer.PDouble, pointer.PBoolean, Random)">nextState</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="findValAct(matrix.MatrixD, matrix.MatrixD, sim.funApp.FunApp, matrix.MatrixD, pointer.PBoolean)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="findValAct"><b>findValAct</b></a>
<pre>
 public double findValAct(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                          <a href="matrix.MatrixD.html#_top_">MatrixD</a> action,
                          <a href="sim.funApp.FunApp.html#_top_">FunApp</a> f,
                          <a href="matrix.MatrixD.html#_top_">MatrixD</a> outputs,
                          <a href="pointer.PBoolean.html#_top_">PBoolean</a> valueKnown) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Find the value and best action of this state.  This returns the value of a given state as a double.
 This also destroys the action that is passed in by replacing it with the best action.  This
 method always returns a value that is a function of state/action pairs.  The value associated with
 these state/action pairs might be Q-values or advantages, but it is not important to know which
 learning algorithm is being used.  This method should simply find the min or max value as a function
 of the state/action pairs in the given state.  For example, if Q-learning is the learning algorithm,
 then one would find the max Q-value for the given state and return that value.
 The action associated with that Q-value would be passed back.  The state/action pair with the
 max Q-value should be evaluated last so that findGradients() can be called from within
 the learning algorithm without having to call function.evaluate().
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> column vectors are wrong size or shape
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#findValAct(matrix.MatrixD, matrix.MatrixD, sim.funApp.FunApp, matrix.MatrixD, pointer.PBoolean)">findValAct</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="findValue(matrix.MatrixD, matrix.MatrixD, pointer.PDouble, sim.funApp.FunApp, pointer.PDouble, matrix.MatrixD, pointer.PDouble, pointer.PBoolean, expression.NumExp, Random)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="findValue"><b>findValue</b></a>
<pre>
 public double findValue(<a href="matrix.MatrixD.html#_top_">MatrixD</a> state,
                         <a href="matrix.MatrixD.html#_top_">MatrixD</a> action,
                         <a href="pointer.PDouble.html#_top_">PDouble</a> gamma,
                         <a href="sim.funApp.FunApp.html#_top_">FunApp</a> f,
                         <a href="pointer.PDouble.html#_top_">PDouble</a> dt,
                         <a href="matrix.MatrixD.html#_top_">MatrixD</a> outputs,
                         <a href="pointer.PDouble.html#_top_">PDouble</a> reinforcement,
                         <a href="pointer.PBoolean.html#_top_">PBoolean</a> valueKnown,
                         NumExp explorationFactor,
                         <a href="Random.html#_top_">Random</a> random) throws <a href="matrix.MatrixException.html#_top_">MatrixException</a>
</pre>
<dl>
  <dd> Find the max over action for <R+gammaV(x')> where V(x') is the value of the successor state
 given state x, R is the reinforcement, gamma is the discount factor.  This method is used in
 the object ValIteration (value iteration). The max value over actions (<R+gammaV(x')>) is returned.
 The state associated with the optimal action is return 1-explorationFactor percent of the time.
 Otherwise, a random next state is returned.  The next state is passed back in state.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="matrix.MatrixException.html#_top_">MatrixException</a>
    <dd> column vectors are wrong size or shape
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#findValue(matrix.MatrixD, matrix.MatrixD, pointer.PDouble, sim.funApp.FunApp, pointer.PDouble, matrix.MatrixD, pointer.PDouble, pointer.PBoolean, expression.NumExp, Random)">findValue</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="BNF(int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="BNF"><b>BNF</b></a>
<pre>
 public String BNF(int lang)
</pre>
<dl>
  <dd><dl>
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#BNF(int)">BNF</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<a name="unparse(parse.Unparser, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="unparse"><b>unparse</b></a>
<pre>
 public void unparse(<a href="parse.Unparser.html#_top_">Unparser</a> u,
                     int lang)
</pre>
<dl>
  <dd> Output a description of this object that can be parsed with parse().
 Also creates the state/action/nextState vectors
<p>
  <dd><dl>
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#unparse(parse.Unparser, int)">unparse</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
    <dt> <b>See Also:</b>
    <dd> <a href="parse.Parsable.html#_top_">Parsable</a>
  </dl></dd>
</dl>
<a name="parse(parse.Parser, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="parse"><b>parse</b></a>
<pre>
 public Object parse(<a href="parse.Parser.html#_top_">Parser</a> p,
                     int lang) throws <a href="parse.ParserException.html#_top_">ParserException</a>
</pre>
<dl>
  <dd> Parse the input file to get the parameters for this object.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="parse.ParserException.html#_top_">ParserException</a>
    <dd> parser didn't find the required token
    <dt> <b>Overrides:</b>
    <dd> <a href="sim.mdp.MDP.html#parse(parse.Parser, int)">parse</a> in class <a href="sim.mdp.MDP.html#_top_">MDP</a>
  </dl></dd>
</dl>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-sim.mdp.html">This Package</a>  <a href="Package-sim.mdp.html">Previous</a>  <a href="sim.mdp.HC.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
