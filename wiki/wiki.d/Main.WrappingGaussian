version=pmwiki-2.1.26 ordered=1 urlencoded=1
agent=Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.7.13) Gecko/20060418 CentOS/1.7.13-1.4.1.centos4
author=
csum=
ctime=1160066746
host=128.119.241.208
name=Main.WrappingGaussian
rev=8
targets=
text=Here's a way to represent a Gaussian-like function on a space periodic with a frequence of 2pi (e.g., angles, so that 0.3 radians and 2pi+0.3 radians are the same). The sample code is in Matlab. %0a%0a'''Gaussian.m''' is the regular Gaussian function:%0a[@%0afunction y = Gaussian(xminusm,dimx,invC,detC)%0a%0a%25 xminusm is simply x - m%0a%25 dimx is the dimension of x (and m)%0a%25 invC is the inverse of the covariance matrix%0a%25 detC is the determinant of the covariance matrix%0a%0ay = exp(-0.5*xminusm'*invC*xminusm)/(((2*pi)^dimx/2)*sqrt(detC));%0a@]%0a%0a%0aFor dimensions of x-m that you want to be represented as periodic with frequence 2pi, replace the stimulus values at those dimensions with acos(cos(x-m)):%0a[@%0aCovarianceMatrix = [whatever it is];%0ainvC = inv(CovarianceMatrix);%0adetC = det(CovarianceMatrix);%0adimx = length(x);%0a%0awrappedindices = [1 3 5];%0a  %25 this means that only dimensions 1,3, and 5 are periodic%0a%0astimulus = x-m;%0awrappedstimulus = acos(cos(x-m));%0astimulus(wrappedindices) = wrappedstimulus(wrappedindices);%0a%0ay = Gaussian(stimulus,dimx,invC,detC);%0a%0a@]%0a%0aObviously, tweak as you see fit, particularly if there's a more efficient way to do this. Also, if you want the function to be periodic with frequencies other than 2pi, I'm sure there's a way to tweak the cosine function to reflect the frequency you want.%0a%0aNote: in the first sentence of this page, I say "Gaussian-like" because it's not normalized anymore. If you know how to normalize it, please say how. Also, while this is fine with independent dimensions, I'm not sure how this would work for systems in which the non-diagonal elements of the covariance matrix are non-zero.%0a%0aAlso, suppose you want to use this function once to do a lot of Gaussians (e.g., x-m is actually a matrix of size [dimension of x] X [number of occurances]). You can use the Gaussian function as is, but it returns a matrix, the diagonal of which is the array of values you actually want. (I don't know what the off-diagonoal elements represent). To isolate the main diagonal, use the matlab function "spdiags(x,0)". This returns the elements of the main diagonal of the square matrix x. (Replace 0 with other integers to isolate off-diagonal elements.)%0a
time=1161286864
author:1161286864=
diff:1161286864:1161272930:=36,38c36%0a%3c Note: in the first sentence of this page, I say "Gaussian-like" because it's not normalized anymore. If you know how to normalize it, please say how. Also, while this is fine with independent dimensions, I'm not sure how this would work for systems in which the non-diagonal elements of the covariance matrix are non-zero.%0a%3c %0a%3c Also, suppose you want to use this function once to do a lot of Gaussians (e.g., x-m is actually a matrix of size [dimension of x] X [number of occurances]). You can use the Gaussian function as is, but it returns a matrix, the diagonal of which is the array of values you actually want. (I don't know what the off-diagonoal elements represent). To isolate the main diagonal, use the matlab function "spdiags(x,0)". This returns the elements of the main diagonal of the square matrix x. (Replace 0 with other integers to isolate off-diagonal elements.)%0a---%0a> Note: in the first sentence of this page, I say "Gaussian-like" because it's not normalized anymore. Also, while this is fine with independent dimensions, I'm not sure how this would work for systems in which the non-diagonal elements of the covariance matrix are non-zero.%0a
host:1161286864=128.119.241.208
author:1161272930=
diff:1161272930:1160481864:=34,35c34,35%0a%3c Obviously, tweak as you see fit, particularly if there's a more efficient way to do this. Also, if you want the function to be periodic with frequencies other than 2pi, I'm sure there's a way to tweak the cosine function to reflect the frequency you want.%0a%3c %0a---%0a> Obviously, tweak as you see fit, particularly if there's a more efficient way to do this.%0a> %0a
host:1161272930=128.119.241.208
author:1160481864=
diff:1160481864:1160411358:=30,31c30,31%0a%3c y = Gaussian(stimulus,dimx,invC,detC);%0a%3c %0a---%0a> y = Gaussian(wrappedstimulus,dimx,invC,detC);%0a> %0a
host:1160481864=24.181.235.154
author:1160411358=
diff:1160411358:1160407580:=34,36c34%0a%3c Obviously, tweak as you see fit, particularly if there's a more efficient way to do this.%0a%3c %0a%3c Note: in the first sentence of this page, I say "Gaussian-like" because it's not normalized anymore. Also, while this is fine with independent dimensions, I'm not sure how this would work for systems in which the non-diagonal elements of the covariance matrix are non-zero.%0a---%0a> Obviously, tweak as you see fit, particularly if there's a more efficient way to do this. Note: in the first sentence of this page, I say "Gaussian-like" because it's not normalized anymore. Also, while this is fine with independent dimensions, I'm not sure how this would work for systems in which the non-diagonal elements of the covariance matrix are non-zero.%0a
host:1160411358=128.119.241.208
author:1160407580=
diff:1160407580:1160407389:=34c34%0a%3c Obviously, tweak as you see fit, particularly if there's a more efficient way to do this. Note: in the first sentence of this page, I say "Gaussian-like" because it's not normalized anymore. Also, while this is fine with independent dimensions, I'm not sure how this would work for systems in which the non-diagonal elements of the covariance matrix are non-zero.%0a---%0a> Obviously, tweak as you see fit. Note: in the first sentence of this page, I say "Gaussian-like" because it's not normalized anymore. Also, while this is fine with independent dimensions, I'm not sure how this would work for systems in which the non-diagonal elements of the covariance matrix are non-zero.%0a
host:1160407580=128.119.241.208
author:1160407389=
diff:1160407389:1160141801:=1,3c1,3%0a%3c Here's a way to represent a Gaussian-like function on a space periodic with a frequence of 2pi (e.g., angles, so that 0.3 radians and 2pi+0.3 radians are the same). The sample code is in Matlab. %0a%3c %0a%3c '''Gaussian.m''' is the regular Gaussian function:%0a---%0a> This simply makes a 1D Gaussian, but includes a way to wrap it around so you can deal with angles (e.g., 2pi + 1 and 1 would have the same value). %0a> %0a> %0a5,34c5,29%0a%3c function y = Gaussian(xminusm,dimx,invC,detC)%0a%3c %0a%3c %25 xminusm is simply x - m%0a%3c %25 dimx is the dimension of x (and m)%0a%3c %25 invC is the inverse of the covariance matrix%0a%3c %25 detC is the determinant of the covariance matrix%0a%3c %0a%3c y = exp(-0.5*xminusm'*invC*xminusm)/(((2*pi)^dimx/2)*sqrt(detC));%0a%3c @]%0a%3c %0a%3c %0a%3c For dimensions of x-m that you want to be represented as periodic with frequence 2pi, replace the stimulus values at those dimensions with acos(cos(x-m)):%0a%3c [@%0a%3c CovarianceMatrix = [whatever it is];%0a%3c invC = inv(CovarianceMatrix);%0a%3c detC = det(CovarianceMatrix);%0a%3c dimx = length(x);%0a%3c %0a%3c wrappedindices = [1 3 5];%0a%3c   %25 this means that only dimensions 1,3, and 5 are periodic%0a%3c %0a%3c stimulus = x-m;%0a%3c wrappedstimulus = acos(cos(x-m));%0a%3c stimulus(wrappedindices) = wrappedstimulus(wrappedindices);%0a%3c %0a%3c y = Gaussian(wrappedstimulus,dimx,invC,detC);%0a%3c %0a%3c @]%0a%3c %0a%3c Obviously, tweak as you see fit. Note: in the first sentence of this page, I say "Gaussian-like" because it's not normalized anymore. Also, while this is fine with independent dimensions, I'm not sure how this would work for systems in which the non-diagonal elements of the covariance matrix are non-zero.%0a---%0a> function y = WrapGaussian(th,pd,sd)%0a> %0a> %25 th is the stimulus angle%0a> %25 it is presented to an array of Gaussians, each with a different %0a> %25   center. %0a> %25 pd is column vector of PDs, a PD is the center of the Gaussian%0a> %25 y is the activity of the array in response to th%0a> %0a> if exist('sd') == 0%0a>   sd = 1;%0a> end%0a> %0a> th0 = th;%0a> %0a> tmp = th/(2*pi);%0a> %0a> if tmp > 1%0a>   th = th - 2*pi*floor(tmp);%0a> elseif tmp %3c 0  %0a>   th = th + 2*pi - 2*pi*ceil(tmp);%0a> end%0a> %0a> y = max([exp(-((pd-th).^2)/sd)'; exp(-(((pd-2*pi)-th).^2)/sd)'; exp(-(((pd+2*pi)-th).^2)/sd)']);%0a> %0a> @]%0a\ No newline at end of file%0a
host:1160407389=128.119.241.208
author:1160141801=
diff:1160141801:1160066746:=
host:1160141801=128.119.241.208
author:1160066746=
diff:1160066746:1160066746:=1,29d0%0a%3c This simply makes a 1D Gaussian, but includes a way to wrap it around so you can deal with angles (e.g., 2pi + 1 and 1 would have the same value). %0a%3c %0a%3c %0a%3c [@%0a%3c function y = WrapGaussian(th,pd,sd)%0a%3c %0a%3c %25 th is the stimulus angle%0a%3c %25 it is presented to an array of Gaussians, each with a different %0a%3c %25   center. %0a%3c %25 pd is column vector of PDs, a PD is the center of the Gaussian%0a%3c %25 y is the activity of the array in response to th%0a%3c %0a%3c if exist('sd') == 0%0a%3c   sd = 1;%0a%3c end%0a%3c %0a%3c th0 = th;%0a%3c %0a%3c tmp = th/(2*pi);%0a%3c %0a%3c if tmp > 1%0a%3c   th = th - 2*pi*floor(tmp);%0a%3c elseif tmp %3c 0  %0a%3c   th = th + 2*pi - 2*pi*ceil(tmp);%0a%3c end%0a%3c %0a%3c y = max([exp(-((pd-th).^2)/sd)'; exp(-(((pd-2*pi)-th).^2)/sd)'; exp(-(((pd+2*pi)-th).^2)/sd)']);%0a%3c %0a%3c @]%0a\ No newline at end of file%0a
host:1160066746=128.119.241.208
